#!/bin/bash

# Retrieve the script path
SCRIPT=$(readlink -f "$0")
SCRIPTPATH=$(dirname "$SCRIPT")

# Define the source and destination paths
clone_path="$SCRIPTPATH/symbols"
output_path="$SCRIPTPATH/symbols.txt"

# Clone the latest KiCAD footprints from repository if not already present
if [ ! -d "$clone_path" ]; then
    git clone --depth 1 https://gitlab.com/kicad/libraries/kicad-symbols.git "$clone_path"
else 
    cd "$clone_path"
    git pull
    cd "$SCRIPTPATH"
fi

# Empty the output file
> "$output_path"

# Put a header in the output file
echo "# This file contains all the KiCad symbols available in the official library" >> "$output_path"
echo "# Generated by symbols.sh" >> "$output_path"
echo "# on $(date)" >> "$output_path"


# Iterate over all kicad_sym files
# Using -printf helps avoid complex string stripping later
find "$clone_path" -type f -name "*.kicad_sym" | while read -r file; do
    
    # 1. Get the directory name relative to clone_path
    rel_dir=$(dirname "${file#$clone_path/}")
    
    # 2. Get the filename without the extension
    lib_name=$(basename "$file" .kicad_sym)

    # 3. Combine them. If the file is in the root of 'symbols', skip the dir prefix
    if [ "$rel_dir" == "." ]; then
        full_prefix="$lib_name"
    else
        full_prefix="${rel_dir}:${lib_name}"
    fi

    # 4. Extract symbols (Original logic style)
    symbols=$(grep -oP "\(symbol \"(.+)\"" "$file" | sed "s|(symbol \"||" | sed "s|\"||")

    # 5. Remove subunits (_1_2, etc.)
    symbols=$(echo "$symbols" | grep -Pv "_[0-9]+_[0-9]+$")

    # 6. Prepend the corrected prefix and append to output
    if [ ! -z "$symbols" ]; then
        echo "$symbols" | sed "s|^|$full_prefix:|" >> "$output_path"
    fi
done

echo "Found $(wc -l < "$output_path") symbols"